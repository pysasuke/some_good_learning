第一章、Java开发中通用的方法和准则
1.不要在常量和变量中出现易混淆的字母
2.莫让常量蜕变成变量
3.三元操作符的类型务必一致
4.避免带有变长参数的方法重载
5.别让null值和空值威胁到变长方法
6.覆写变长方法也循规蹈矩
7.警惕自增的陷阱
8.不要让旧语法困扰你
9.少用静态导入
10.不要在本类中覆盖静态导入的变量和方法
11.养成良好习惯，显示声明UID
12.避免用序列化类在构造函数中为不变量赋值
13.避免final变量复杂赋值
14.使用序列化类的私有方法巧妙解决部分属性持久化问题
15.break万万不可忘
16.易变业务使用脚本语言编写
17.慎用动态编译
18.避免instanceof非预期结果
19.断言绝对不是鸡肋
20.不要只替换一个类

第二章、基本类型
21.用偶判断，不用奇判断
22.用整数类型处理货币
23.不要让类型默默转换
24.边界，边界，还是边界
25.不要让四舍五入亏了一方
26.堤防包装类型的null值
27.谨慎包装类型的大小比较
28.优先使用整型池
29.优先选择基本类型
30.不要随便设置随机种子

第三章、类、对象及方法
31.在接口中不要存在实现代码
32.静态变量一定要先声明后赋值
33.不要覆写静态方法
34.构造函数尽量简化
35.避免在构造函数中初始化其他类
36.使用构造代码块精炼程序
37.构造代码块会想你所想
38.使用静态内部类提高封装性
39.使用匿名类的构造函数
40.匿名类的构造函数很特殊
41.让多重继承成为现实
42.让工具类不可实例化
43.避免对象的浅拷贝
44.推荐使用序列化实现对象拷贝
45.覆写equals方法时不要识别不出自己
46.equals应该考虑null值情景
47.在equals中使用getClass进行类型判断
48.覆写equals方法必须覆写hashCode方法
49.推荐覆写toString方法
50.使用package-info类为包服务
51.不要主动进行垃圾回收

第四章、字符串
52.推荐使用String直接量赋值
53.注意方法中传递的参数要求
54.正确使用String、StringBuffer、StringBuilder
55.注意字符串的位置
56.自由选择字符串拼接方法
57.推荐在复杂字符串操作中使用正则表达式
58.强烈建议使用UTF编码
59.对字符串排序持一种宽容的心态

第五章、数组和集合
60.性能考虑，数组是首选
61.若有必要，使用变长数组
62.警惕数组的浅拷贝
63.在明确的场景下，为集合指定初始容量
64.多种最值算法，适时选择
65.避开基本类型数组转换列表陷阱
66.asList方法产生的List对象不可更改
67.不同的列表选择不同的遍历方法
68.频繁插入和删除时使用LinkedList
69.列表相等只需关心元素数据
70.子列表只是元列表的一个视图
71.推荐使用subList处理局部列表
72.生成子列表后不要再操作原列表
73.使用Comparator进行排序
74.不推荐使用binarySearch对列表进行检索
75.集合中的元素必须做到compareTo和equals同步
76.集合运算时使用更优雅的方法
77.使用shuffle打乱列表
78.减少HashMap中元素的数量
79.集合中的哈希码不要重复
80.多线程使用Vector或HashTable
81.非稳定排序推荐使用List
82.由点及面，一叶知秋——集合大家族

第六章、枚举和注解
83.推荐使用枚举定义常量
84.使用构造函数协助描述枚举项
85.小心switch带来的控制异常
86.在switch的default代码块中增加AssertionError错误
87.使用ValueOf前必须进行校验
88.用枚举实现工厂方法模式更简洁
89.枚举项的数量限制在64个以内
90.小心注解继承
91.枚举和注解结合使用威力更大
92.注意@Override不同版本的区别

第七章、泛型和反射
93.Java的泛型是类型擦除的
94.不能初始化泛型参数和数组
95.强制声明泛型的实际类型
96.不同的场景使用不同的泛型通配符
97.警惕泛型是不能协变和逆变的
98.建议采用的顺序是List<T>、List<?>、List<Object>
99.严格限定泛型类型采用多重界限
100.数组的真实类型必须是泛型类型的子类型
101.注意Class类的特殊性
102.适时选择getDeclaredXXX和getXXX
103.反射访问属性或方法时将Accessible设置为true
104.使用forName动态加载类文件
105.动态加载不适合数组
106.动态代理可以使代理模式更加灵活
107.使用反射增强装饰模式的普适性
108.反射让模板方法模式更强大
109.不需要太关注反射效率

第八章、异常
110.提倡封装异常
111.采用异常链传递异常
112.受检异常尽可能转化为非受检异常
113.不要在finally块中处理返回值
114.不要在构造函数中抛出异常
115.使用Throwable获得栈信息
116.异常只为异常服务
117.多使用异常，把性能问题放一边

第九章、多线程和并发
118.不推荐覆写start方法
119.启动线程前stop方法是不可靠的
120.不使用stop方法停止线程
121.线程优先级只使用三个等级
122.使用线程异常处理器提升系统可靠性
123.volatile不能保证数据同步
124.异步运算考虑使用Callable接口
125.优先选择线程池
126.适时选择不同的线程池来实现
127.Lock与synchronized是不一样的
128.预防线程死锁
129.适当设置阻塞队列长度
130.使用CountDownLatch协调子线程
131.CyclicBarrier让多线程齐步走

第十章、性能和效率
132.提升Java性能的基本方法
133.若非必要，不要克隆对象
134.推荐使用“望闻问切”的方式诊断性能
135.必须定义性能衡量标准
136.枪打出头鸟——解决首要系统性能问题
137.调整JVM参数以提升性能
138.性能是个大“咕咚”

第十一章、开源世界
139.大胆采用开源工具
140.推荐使用Guava扩展工具包
141.Apache扩展包
142.推荐使用Joda日期时间扩展包
143.可以选择多种Collections扩展

第十二章、思想为源
144.提倡良好的代码风格
145.不要完全依赖单元测试来发现问题
146.让注释正确、清晰、简洁
147.让接口的职责保持单一
148.增强类的可替换性
149.依赖抽象而不是实现
150.抛弃7条不良的编码习惯
151.以技术员自律而不是工人